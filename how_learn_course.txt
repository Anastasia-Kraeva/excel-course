во время просмотра вникать и повторять логические 
кусочки за преподом

перед тем как перейти к следующему видео просмотреть
код и вслух описать каждую строчку

сделать что-то свое на основе пройденного

выполнять доп задания

в курсе JavaScript посмотреть:
EcmaScript
JavaScript интервью (курс по собеседованию)
дебаг

посмотреть
https://www.youtube.com/watch?v=3aGSqasVPsI&ab_channel=%D0%92%D0%BB%D0%B0%D0%B4%D0%B8%D0%BB%D0%B5%D0%BD%D0%9C%D0%B8%D0%BD%D0%B8%D0%BD

-пересмотрела 16 урок

*11 урок таймкоды
00.20 создаем проект
создать папку в консоли 
mkdir <name>



*12 
08.05 не работает clear + появился файл desktop.init

*13
02.08 инициализируем проект git init -y
06.43 устанавливаем webpack
07.42 заполняем webpack.config.js
12.50 добавляем скрипты в json

*14
подключилa плагины: html, copy, clean, minicss
создали index.html
07.00 подключили favicon.ico
09.30 в настройки вэбпака добавляем resolve

*15
00.08 loaders: sass, css 
код проходит через лодеры начиная с нижнего 
02.45 создаем папку со стилями и index.scss
03.00 создаем и подключаем в js стили 
затем собираем проект
04.20 подключаем Babeljs в webpack
09.07 указываем браузеры

*16
создаем флаги для режима сборки приложения
01.08 npm i -D cross-env (у влада не минифицировался html он настраивал это на 03.25)
04.50 создает ф-ю именования
06.08 sourceMaps
*** на сайте webpack-а в разделе configuration описаны все настройки там нужно посмотреть про devtool
08.16 devServer
08.55 настройка для динамической сборки проекта (в режиме разработки)
12.20 устраняем 'regeneratorRuntime is not defined' с помощью полифилов бабель (вкладка doc/usage/polyfill)

*17
не подчеркиваются ошибки eslint

*18
запушили и слили ветки

*19
вступление для блока верстки

*20
макет

*21
в css не работает путь '~normalize.css'

*22
не работает вставка иконок как в доках гугла (там исп-ся спан а у владилена тег i)
<span class="material-icons-outlined">delete</span>
<i class="material-icons">delete</i>

скопировала все стили и html
13,20 начало про миксины
*23
*24
чтобы сделать див инпутом можно добавить ему аттрибут contenteditable
а чтобы не проверялись ошибки в тексте добавить spellcheck="false"
*25
*26
*27
сбилдить все стили в один css
*28
*29
*30 очень важно: создание структуры классов
structure:
  core:
    Dom
    DomListener
      ExelComponent
        Header, ets.

(как вриант назвать дом элементы через $)
ctrl + alt + L вроде чистит предупреждения ес линта а может сам форматирует
не работавют алиасы путей
*31
*32
static свойство позволяет исп его без создания экземпляра
*33 раздел 3 урок 5 "класс для работы с дом"
*34 подготовка структуры для событий
*35 добавление прослушки событий
*36 удаление слушателей
если вызвать метод обьекта как callback и вызывать его при помощи квадратных скобок то метод теряет контекст (например в setTimeout) чтобы избежать этого контекст можно привязать при помощи bind но он не просто привязывает ф-ю а создает новую с нужным контекстом. Чтобы иметь возможность потом в объекте обратиться именно к этой ф-ии можно присваевать ее как свойство.
Например:
this[method] = this[method].bind(this)
this.$root.on(listener, this[method])
this.$root.off(listener, this[method])
оба метода будут смотреть на одну ф-ю (метод объекта привязанный к своему объекту)
*37 создание таблицы. заголовки
у символов есть метод возвращающий код символа (который можно исп для обратного декодирования в символ)
'A'.charCodeAt() === 65  =>  String.fromCharCode(65) === "A"
в коде нежелательно исп числа поэтому коды букв вложим в объект
можно создать массив при пом класса и пройти по нему несколькими методами выстроив их в цепочку
если атрибут ф-ии не исп то его можно обозначить нижним подчеркиванием
у методов массивов можно передать ф-ю как референс (перенаправить входные данные в нее)
чтобы создать разметку таблицы можно положить в массив строки с разметкой а потом объединить их при помощи join с пустой строкой в кач-ве разделителя
*38 создание ячейки
*39 git flow
для дебага можно выносить данные в глобальную область виддимости
например:
window['c' + component.name] = component (компонент теперь доступен отовсюду)

*40 вступление
--------------Раздел 4. Ресайз-----------------------------------
*41 алгоритм действия событий
*42 создаем эл для ресайза (урок 2 содержит не тот контент хотя заголовок верный)
*43 определяем эл-ы для ресайза
домузлам можно добавлять кастомные аттрибуты с помощью приставки "data-"
затем аттрибуты узла можно получить и на их основе строить логику. Так между слоем логики и представления появляется прослойра позволяющая корректировать отрисовку не переделывая логику (как это было бы если бы мы опирплись на названия классов а потом изменили бы их)
напрпимер:
console.log(e.target.getAttribute('data-resize'))
кастомные аттрибуты можно получить в более удобном формате с пом св-ва "dataset"
console.log(e.target.dataset)
*44 изменяем ширину колонок
чтобы обратиться к родителю узла вместо метода parentNode можно исп метод поиска родителя с условием
это поможет если нужный родитель перестанет быть прямым родителем
<node name>.closest(<criterion>)
метод получения расположения ноды на экране:
<node name>.getBoundingClientRect()
*45 проблемы с производительностью
если создать геттер то он вернет значение без исп-я круглых скобок
например
get data() {
  return this.$el.dataset
}
$parent.data
запросы к дом-дереву очень затратны
досмотрела
нужно придумать несколько способов как оптимизнуть ресайз (слишком часто сраб мув)
*46 оптимизация
чтобы оптимизировать ресайз мы:
изменили узел в которо ищем эл-ы с нужным номером колонки (с документа на рут (див, таблица))
перенесли запрос к дому из мува в доун-событие и положили в переменную
*47 ресайз строк
*48 утилита для работы со стилями
вместо for in лучше исп метод keys а затем forEach
Object.keys(styles).forEach(key => {})
*49 существенная оптимизация
задание:
с ползунком (показывать разметку а не ресайзить сразу)
с оптимизацией
при срабатывании onmouseup нужно чистить не только onmousemove но и сам onmouseup
эл-ту ресавйзер не хватало z-index 1000
*50 продолжение, мерж
--------------Раздел 5. Логика excel-----------------------------------
*51 вступление (типа урок 1)
*52 выделение
*53
при переопределении метода можно как в конструкторе вызвать сначала метод родителя например в init:
super.init()
колбек ф-ю мы заменили на рекурссивную ф-ю
получилось так что мы вернули из toCell такую же безымянную ф-ю как в колбеке но row получаем уже не напрямую из map а
передаем ее при вызове toCell и потом вернувшаяся ф-я будет вызвана с данными из map но уже имея доступ к прошлому значению
было:
.map(toCell)
колбэк:
.map((_, col) => toCell(row, col))
рекурсия:
.map(toCell(row))

а toCell теперь возвращает прошлую версию себя (т.е. ф-ю принимающую номер колонки (от map) и возвращающую разметку но уже с
атрибутом data-id на основе индексов колонки и строчки)
*54 выбор др ячейки
для выбора др ячейки он положил эл-ы в массив и при клике очищает стили эл-в из массива -> очищает его и добавляет новые эл-ы
*55 13.45
чтобы создать массив (матрицу) на основе двух массивов он использует reduce с аккумулятором = []
const ids = cols.reduce((acc, col) =>{
          rows.forEach(row => acc.push(`${row}:${col}`))
          return acc
        }, [])

*56 досмотрела
*57 вступление
*58 реализация observer (паттерн подписчик)
*59 взаимодействие между компонента
*60 улучшение фреимворка
*61 обратное связывание формулы с таблицей
*62 мерж
*63 введение
--------------Раздел 6. Состояние приложения-----------------------------------
*64 что такое состояние
*65 создание сторы
*66 связывание store и UI
*67 состояние колонок
*68 сохранение состояния
*69 рендер состояния
почему на одном из прошлых уроков обернули ф-ю ресайза в промис
*70 сохранение измененной высоты строк
*71 сохранение значений в ячейках
*72 оптимизация логики подписок
*73 создание тулбара
*74 компонент с состоянием
*75 определение стилей ячейки
*76 изменение стилей через store
*77 сохранение стилей
*78 изменение названия таблицы
*79 оптимизация с debounсe
*80 парсинг ячеек (с помощью eval)
*81 мерж